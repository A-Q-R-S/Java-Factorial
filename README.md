# Java-Factorial

Намиране на факториел.

Работата по проекта се концентрира върху декомпозицията, балансирането и използването на оптимална грануларност на елементите. 
Synchronized частта е сведена единствено до търсене (searcher), като генерирането на междинните резултати и обединяването им (calculator) става паралелно, минимизирайки изчакването. 
Използва се общ масив за съхранение, но няма конфликти при достъпване на памет, т.к. клетките се заключват в (synchronized) searcher. Отделните нишки имат нужда от достъп до различни участъцина масива.


•	User Interface:

  o	Програмата очаква вход: брой нишки – цяло неотрицателно число. При неспазване повтаря заявката.
  
  o	При вход 0, системата пита за вход в режим симулация:
  
             o	Програмата очаква вход: брой нишки – цяло неотрицателно число. При неспазване повтаря заявката.
	       o	При вход 0, системата пита за вход в режим симулация:
	       По време на анализ бе установено, че използваният алгоритъм разбива работата с числото Х и предава части на нишките, като олекотява     пресмятането. С цел чисто представяне на ускорението е имплементирана възможност за “режим симулация”, който разбива числохо Х по       подобен начин при работа с 1 нишка. В режима се влиза с вход “0” -> брой нишки.
        	При въведено число (>= 2) се използва безнишкова симулация на нишки.
		
        	При въведена втора нула (0) се пресмята безнишково.
		
        	Програмата очаква вход: число за пресмятане – цяло, неотрицателно. При неспазване повтаря заявката.
		
      o	При вход (1) се пресмята безнишково:
	  
        	Програмата очаква вход: число за пресмятане – цяло, неотрицателно. При неспазване повтаря заявката.
      o	При вход (>= 2) се влиза в многонишков режим:
	  
        	Програмата очаква вход: число за пресмятане – цяло, неотрицателно. При неспазване повтаря заявката. 
		
        	Създава се обект от класа Factorial, масив от тип Tripple[], масив от нишки, които се инициализират и стартират.
		
•	Замерва се времето на изпълнение на програмата.

•	Резултатът се записва във файл с разширение “txt” поради големия обим на съдържанието.

•	“workSplit” може да се имплементира като част от UI или автоматично генериран обект спрямо входните данни. (workSplit е статичен обект, отговарящ за броя и състава на частите на декомпозиция 2-ро ниво).




v1.0
1)	Изходното число бива разбито на отделни части за отделните нишки.
2)	(паралелно) Нишките генерират изчисления оптимално балансирано и с максимална грануларност.
3)	(синхронизирано) Нишките умножават резултата си към общия резилтат.
Тази реализация създава известно ускорение, но тъй като обединяването на резултатите става стъпка по стъпка за всяка нишка, останалите трябва да изчакват.

v2.0	Генериране, записване, търсене, калкулация, убиване
1)	Изходното число бива разбито на отделни части за отделните нишки.
2)	(паралелно) Нишките генерират изчисления оптимално балансирано и с максимална грануларност.
3)	(паралелно) Резултатите се записват в масив.
4)	(синхронизирано) Нишките започват режим “търсене”, като при намерени две клетки, те се “заключват”.
5)	(паралелно) Заключените клетки са достъпни само на намерилата ги нишка. Резултатите се сливат и клетката носител се отключва. Нишката умира.
- връщане към т.4) – 
Тази реализация премахва излишното изчакване, като изпълнява просто търсене в масива. Клетките се заключват в частна сесия и са недостъпни за другите нишки. След всяко сливане на 2 резултата “умира” (завършва) по една нишка.

v2.1	Генериране, записване, търсене, калкулация, убиване, заспиване/събуждане
•	Включено е заспиване и събуждане на нишките. (синхронизирано) Установи се, че не е необходимо, т.к. излишните биват убити.

v3.0	Генериране, записване, търсене, калкулация, убиване, 
разпадане, по-фина грануларност
1)	Изходното число бива разбито на отделни части за отделните нишки.
2)	Частта на всяка нишка се “разпада” на парчета.
3)	(паралелно) Нишките генерират изчисления оптимално балансирано и с максимална грануларност.
4)	(паралелно) Резултатите се записват в масив.
5)	(синхронизирано) Нишките започват режим “търсене”, като при намерени две клетки, те се “заключват”.
6)	(паралелно) Заключените клетки са достъпни само на намерилата ги нишка. Резултатите се сливат и клетката носител се отключва. Животът на нишката се скъсява.
7)	– връщане към т.3) – при изчислени всички парчета нишката умира –
Тази реализация разбива работата на нишките и олекотява пресмятането.



